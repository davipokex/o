<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>CONIR - ULTRA MEGA (MEJORADO)</title>

  <!-- Bootstrap (opcional, solo para los botones) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />

  <style>
    :root{
      --bg-1: #050507;
      --neon-pink: #ff00aa;
      --neon-cyan: #00ffe0;
      --neon-amber: #ffae00;
      --card-w: 220px;
      --card-h: 320px;
      --card-w-sm: 130px;
      --card-h-sm: 190px;
    }

    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%;width:100%;background:radial-gradient(circle at 30% 20%, #0b0b0c 0%, #000 70%);font-family:Inter, Poppins, system-ui, sans-serif;color:#fff;overflow:hidden}

    /* Canvas background layers */
    canvas#bg, canvas#connect, canvas#trails {
      position: fixed; left:0; top:0; width:100%; height:100%; z-index:-4;
      pointer-events: none;
    }

    .bg-glows{
      position: fixed; inset:0; z-index:-3; filter: blur(80px);
      background:
        radial-gradient(circle at 20% 20%, rgba(255,0,170,0.12) 0%, transparent 18%),
        radial-gradient(circle at 80% 80%, rgba(0,255,224,0.10) 0%, transparent 20%),
        radial-gradient(circle at 50% 60%, rgba(255,174,0,0.06) 0%, transparent 25%);
      animation: bgDrift 18s infinite alternate ease-in-out;
    }
    @keyframes bgDrift { from{transform:scale(1) translateY(0)} to{transform:scale(1.15) translateY(-40px)} }

    .stage{
      position:relative; width:100%; height:100vh; display:flex; align-items:center; justify-content:center;
      user-select:none;
    }

    .controls {
      position: fixed; right: 18px; top: 18px; z-index: 9999; display:flex; gap:8px; align-items:center;
      backdrop-filter: blur(6px); padding:8px; border-radius:12px;
      background: linear-gradient(135deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    }
    .badge-mode { font-weight:700; font-size:12px; padding:6px 10px; border-radius:999px; }

    .gallery {
      position:absolute; inset:0; pointer-events:none;
    }
    .card {
      position:absolute;
      width:var(--card-w);
      height:var(--card-h);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6), 0 0 30px rgba(0,0,0,0.5);
      transform-origin: center center;
      transition: box-shadow .35s ease;
      will-change: transform, left, top;
      cursor: grab;
      pointer-events:auto;
      backdrop-filter: blur(6px) saturate(1.2);
      touch-action: none;
    }
    .card:active{ cursor:grabbing }

    .card .frame{
      width:100%; height:100%; display:block; position:relative;
      border-radius:inherit; overflow:hidden;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08));
    }
    /* object-fit cover but center vertical images nicely */
    .card img{
      width:100%; height:100%; object-fit:cover; object-position:center;
      display:block; transition: transform 1s cubic-bezier(.2,1,.2,1), filter .6s ease;
      transform-origin:center center;
      filter: saturate(1.05) contrast(1.02);
      -webkit-user-drag: none;
      user-select:none;
      pointer-events:none;
      image-rendering: auto;
    }

    .card::before{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      box-shadow: 0 0 40px rgba(0,0,0,0.45) inset;
      mix-blend-mode: screen;
    }
    .neon-edge{
      position:absolute; inset:0; border-radius:inherit; pointer-events:none;
      background: linear-gradient(90deg, rgba(255,0,170,0.08), rgba(0,255,224,0.06));
      mix-blend-mode: screen; opacity:0.95;
      transition: opacity .6s;
    }

    .pulse { animation: pulse 3s ease-in-out infinite; }
    @keyframes pulse { 0%{ transform: scale(1)} 50%{ transform: scale(1.035)} 100%{ transform: scale(1)} }
    .wobble { animation: wobble 6s ease-in-out infinite; }
    @keyframes wobble { 0%{ transform: rotate(-4deg)} 50%{ transform: rotate(6deg)} 100%{ transform: rotate(-4deg)} }
    .glitch { position:relative; }
    .glitch::after, .glitch::before{
      content:""; position:absolute; inset:0; pointer-events:none;
      background:inherit; mix-blend-mode: screen; opacity:0.05;
    }
    .glitch::before { transform:translateX(-6px) skewX(-6deg); filter: hue-rotate(200deg); }
    .glitch::after  { transform:translateX(6px) skewX(6deg); filter: hue-rotate(60deg); }

    @media (max-width:900px){
      :root{ --card-w: 160px; --card-h: 230px; }
    }
    @media (max-width:480px){
      :root{ --card-w: var(--card-w-sm); --card-h: var(--card-h-sm); }
      .controls{ left:10px; right:auto; top:10px; padding:6px }
    }

    .focus-overlay {
      position:fixed; inset:0; z-index:9998; display:flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg, rgba(0,0,0,0.55), rgba(0,0,0,0.75)); opacity:0; pointer-events:none; transition:opacity .25s;
    }
    .focus-overlay.show{ opacity:1; pointer-events:auto }

    .focus-card{
      border-radius:14px; max-width:90vw; max-height:90vh; overflow:hidden; display:flex; align-items:center; justify-content:center;
      box-shadow: 0 40px 140px rgba(0,0,0,0.75);
    }
    .focus-card img{ width: auto; height: auto; max-width:100%; max-height:100%; display:block; object-fit:contain; }

    .tiny-btn{ font-size:13px; padding:7px 10px; border-radius:10px; }

    /* reduced motion: respect user preferences */
    @media (prefers-reduced-motion: reduce) {
      .pulse, .wobble, .glitch { animation: none; }
      * { transition: none !important; }
    }

    /* accessibility focus outline */
    .card:focus { outline: 3px solid rgba(255,255,255,0.12); outline-offset:4px; }
  </style>
</head>
<body>
  <canvas id="bg" aria-hidden="true"></canvas>
  <canvas id="trails" aria-hidden="true"></canvas>
  <canvas id="connect" aria-hidden="true"></canvas>

  <div class="bg-glows" aria-hidden="true"></div>

  <div class="controls" role="toolbar" aria-label="Controles de animaciÃ³n">
    <button id="toggleMotion" class="btn btn-dark tiny-btn" aria-pressed="false">PAUSAR</button>
    <button id="shuffleBtn" class="btn btn-outline-light tiny-btn">MEZCLAR</button>
    <span id="modeBadge" class="badge-mode" style="background:linear-gradient(90deg,var(--neon-pink),var(--neon-cyan)); color:black; padding:6px 10px; border-radius:999px; font-weight:700">ULTRA MODE</span>
  </div>

  <div id="focusOverlay" class="focus-overlay" aria-hidden="true" role="dialog" aria-modal="true"></div>

  <div class="stage" id="stage">
    <div class="gallery" id="gallery" aria-hidden="false">
      <!-- Reemplaza las rutas IMAGENES/X.jpg -->
      <div class="card" data-id="1" tabindex="0" role="button" aria-label="Imagen 1"><div class="frame"><img loading="lazy" src="IMAGENES/1.jpg" alt="Imagen 1"></div><div class="neon-edge"></div></div>
      <div class="card" data-id="2" tabindex="0" role="button" aria-label="Imagen 2"><div class="frame"><img loading="lazy" src="IMAGENES/2.jpg" alt="Imagen 2"></div><div class="neon-edge"></div></div>
      <div class="card" data-id="3" tabindex="0" role="button" aria-label="Imagen 3"><div class="frame"><img loading="lazy" src="IMAGENES/3.jpg" alt="Imagen 3"></div><div class="neon-edge"></div></div>
      <div class="card" data-id="4" tabindex="0" role="button" aria-label="Imagen 4"><div class="frame"><img loading="lazy" src="IMAGENES/4.jpg" alt="Imagen 4"></div><div class="neon-edge"></div></div>
      <div class="card" data-id="5" tabindex="0" role="button" aria-label="Imagen 5"><div class="frame"><img loading="lazy" src="IMAGENES/5.jpg" alt="Imagen 5"></div><div class="neon-edge"></div></div>
    </div>
  </div>

  <script>
    // UTILS
    const rand = (a,b) => a + Math.random()*(b-a);
    const clamp = (v,a,b)=> Math.max(a, Math.min(b,v));
    const $ = s => document.querySelector(s);
    const $$ = s => Array.from(document.querySelectorAll(s));

    // ELEMENTS
    const stage = $('#stage');
    const gallery = $('#gallery');
    const cards = $$('.card');
    const bgCanvas = $('#bg');
    const trailsCanvas = $('#trails');
    const connectCanvas = $('#connect');
    const toggleMotionBtn = $('#toggleMotion');
    const shuffleBtn = $('#shuffleBtn');
    const focusOverlay = $('#focusOverlay');
    const modeBadge = $('#modeBadge');

    // contexts
    let bgCtx = bgCanvas.getContext('2d');
    let trailsCtx = trailsCanvas.getContext('2d');
    let connectCtx = connectCanvas.getContext('2d');

    // state
    const state = new Map();
    let motionPaused = false;
    let lastTime = performance.now();
    let rafId = null;

    // particle limits
    const MAX_TRAILS = 350;
    const trailParticles = [];

    // blobs
    let blobs = [];

    // ensure canvases size matches DPR
    function setCanvasSize(canvas){
      const dpr = Math.max(1, devicePixelRatio || 1);
      const w = Math.max(1, Math.round(innerWidth * dpr));
      const h = Math.max(1, Math.round(innerHeight * dpr));
      if(canvas.width !== w || canvas.height !== h){
        canvas.width = w;
        canvas.height = h;
        canvas.style.width = innerWidth + 'px';
        canvas.style.height = innerHeight + 'px';
        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
    }

    // debounce utility for resize
    let resizeTimer = null;
    function handleResize(){
      if(resizeTimer) clearTimeout(resizeTimer);
      resizeTimer = setTimeout(()=> {
        setCanvasSize(bgCanvas);
        setCanvasSize(trailsCanvas);
        setCanvasSize(connectCanvas);
        bgCtx = bgCanvas.getContext('2d');
        trailsCtx = trailsCanvas.getContext('2d');
        connectCtx = connectCanvas.getContext('2d');
        // reposition blobs to remain in view
        initBlobs();
        // refresh state sizes (card offsets may change on responsive)
        cards.forEach(c => {
          const s = state.get(c);
          const rect = c.getBoundingClientRect();
          s.w = rect.width;
          s.h = rect.height;
          // clamp current tx/ty into new bounds
          s.tx = clamp(s.tx, 10, innerWidth - s.w - 10);
          s.ty = clamp(s.ty, 10, innerHeight - s.h - 120);
        });
      }, 120);
    }
    window.addEventListener('resize', handleResize);

    // initialize blobs for background
    function initBlobs(){
      blobs = [];
      const count = Math.max(4, Math.min(10, Math.floor(Math.sqrt(innerWidth+innerHeight)/40)));
      for (let i=0;i<count;i++){
        blobs.push({
          x: rand(0, innerWidth),
          y: rand(0, innerHeight),
          r: rand(80, 260),
          vx: rand(-0.2, 0.2),
          vy: rand(-0.2, 0.2),
          hue: rand(0,360)
        });
      }
    }

    // draw background blobs (cheap gradients)
    function drawBG(){
      bgCtx.clearRect(0,0,innerWidth,innerHeight);
      for (const b of blobs){
        b.x += b.vx;
        b.y += b.vy;
        if(b.x < -300) b.x = innerWidth + 300;
        if(b.x > innerWidth + 300) b.x = -300;
        if(b.y < -300) b.y = innerHeight + 300;
        if(b.y > innerHeight + 300) b.y = -300;
        const g = bgCtx.createRadialGradient(b.x,b.y,b.r*0.1,b.x,b.y,b.r);
        g.addColorStop(0, `hsla(${b.hue},85%,60%,0.14)`);
        g.addColorStop(0.5, `hsla(${(b.hue+40)%360},80%,45%,0.07)`);
        g.addColorStop(1, `rgba(0,0,0,0)`);
        bgCtx.fillStyle = g;
        bgCtx.beginPath();
        bgCtx.arc(b.x,b.y,b.r,0,Math.PI*2);
        bgCtx.fill();
      }
    }

    // trail spawn (bounded)
    function spawnTrail(x,y,color,life=600){
      if(trailParticles.length > MAX_TRAILS) return;
      trailParticles.push({x,y, vx:rand(-0.35,0.35), vy:rand(-0.6,0.6), r:rand(0.8,2.4), color, life, age:0});
    }

    function drawTrails(dt){
      // slight motion blur effect by painting translucent black
      trailsCtx.clearRect(0,0,innerWidth,innerHeight);
      for(let i=trailParticles.length-1;i>=0;i--){
        const p = trailParticles[i];
        p.age += dt;
        if(p.age >= p.life){ trailParticles.splice(i,1); continue; }
        p.x += p.vx * (dt/16);
        p.y += p.vy * (dt/16);
        const alpha = Math.max(0, 1 - (p.age / p.life));
        trailsCtx.beginPath();
        trailsCtx.fillStyle = `rgba(${p.color.r},${p.color.g},${p.color.b},${(alpha*0.9).toFixed(3)})`;
        trailsCtx.arc(p.x, p.y, Math.max(0.5, p.r * (1 + alpha)), 0, Math.PI*2);
        trailsCtx.fill();
      }
    }

    // connections with distance culling (use squared distances for perf)
    function drawConnections(now){
      connectCtx.clearRect(0,0,innerWidth,innerHeight);
      const nodes = cards.map(c => {
        const r = c.getBoundingClientRect();
        return {el:c, x: r.left + r.width/2, y: r.top + r.height/2};
      });
      const maxD = 420;
      const maxD2 = maxD*maxD;
      for(let i=0;i<nodes.length;i++){
        for(let j=i+1;j<nodes.length;j++){
          const a = nodes[i], b = nodes[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          const d2 = dx*dx + dy*dy;
          if(d2 < maxD2){
            const d = Math.sqrt(d2);
            const alpha = clamp(1 - d/maxD, 0.05, 0.75);
            const g = connectCtx.createLinearGradient(a.x,a.y,b.x,b.y);
            g.addColorStop(0, `rgba(255,0,170,${(0.12*alpha).toFixed(3)})`);
            g.addColorStop(1, `rgba(0,255,224,${(0.12*alpha).toFixed(3)})`);
            connectCtx.strokeStyle = g;
            connectCtx.lineWidth = 1.4 * alpha;
            connectCtx.beginPath();
            const cx = (a.x + b.x)/2 + Math.sin(now*0.001 + i)*30;
            const cy = (a.y + b.y)/2 + Math.cos(now*0.001 + j)*20;
            connectCtx.moveTo(a.x,a.y);
            connectCtx.quadraticCurveTo(cx, cy, b.x, b.y);
            connectCtx.stroke();
          }
        }
      }
    }

    // hsv->rgb util
    function hsvToRgb(h, s, v){
      let r,g,b;
      const i = Math.floor(h*6);
      const f = h*6 - i;
      const p = v * (1 - s);
      const q = v * (1 - f*s);
      const t = v * (1 - (1-f)*s);
      switch(i%6){
        case 0: r=v; g=t; b=p; break;
        case 1: r=q; g=v; b=p; break;
        case 2: r=p; g=v; b=t; break;
        case 3: r=p; g=q; b=v; break;
        case 4: r=t; g=p; b=v; break;
        case 5: r=v; g=p; b=q; break;
      }
      return {r: Math.round(r*255), g: Math.round(g*255), b: Math.round(b*255)};
    }

    // apply transform using translate3d for GPU compositing
    function applyTransform(el, x, y, rot){
      el.style.transform = `translate3d(${x}px, ${y}px, 0) rotate(${rot}deg)`;
    }

    // init cards state
    function initCards(){
      cards.forEach((card, idx) => {
        const rect = card.getBoundingClientRect();
        const w = rect.width || parseFloat(getComputedStyle(card).width);
        const h = rect.height || parseFloat(getComputedStyle(card).height);
        const x = rand(60, innerWidth - w - 60);
        const y = rand(60, innerHeight - h - 120);
        const rot = rand(-22,22);
        const orbitRadius = rand(16,130);
        const orbitSpeed = rand(0.0012, 0.006) * (Math.random()>0.5?1:-1);
        const hue = [300,180,40,250,20][idx % 5];
        const color = hsvToRgb(hue/360, 0.9, 0.95);
        const s = {x,y,tx:x,ty:y,rot,orbitRadius,orbitSpeed,ang:rand(0,Math.PI*2),w,h,hue,color,dragging:false};
        state.set(card, s);
        applyTransform(card, x,y,rot);
        // random classes
        if(Math.random() > 0.55) card.classList.add('pulse');
        if(Math.random() > 0.7) card.classList.add('wobble');
        if(Math.random() > 0.85) card.classList.add('glitch');
        setupInteractions(card);
      });
    }

    // interaction: attach pointer handlers dynamically while dragging to reduce global listeners
    function setupInteractions(card){
      let pointerId = null, startX = 0, startY = 0, baseX = 0, baseY = 0, moved = false, lastTap = 0;
      const s = state.get(card);

      function onDown(e){
        // only left mouse or primary touch
        if(e.button && e.button !== 0) return;
        card.setPointerCapture?.(e.pointerId);
        pointerId = e.pointerId;
        moved = false;
        startX = e.clientX; startY = e.clientY;
        baseX = s.tx; baseY = s.ty;
        s.dragging = true;
        card.style.transition = 'transform 0s';
        card.style.zIndex = 10000;
        // double tap
        const now = Date.now();
        if(now - lastTap < 350){ focusCard(card); }
        lastTap = now;
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp, { once: true });
      }

      function onMove(e){
        if(pointerId === null) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        if(Math.abs(dx) > 5 || Math.abs(dy) > 5) moved = true;
        s.tx = clamp(baseX + dx, 8, innerWidth - s.w - 8);
        s.ty = clamp(baseY + dy, 8, innerHeight - s.h - 120);
      }

      function onUp(e){
        card.releasePointerCapture?.(pointerId);
        pointerId = null;
        s.dragging = false;
        card.style.transition = '';
        card.style.zIndex = '';
        if(moved){
          s.ang += rand(-0.6,0.6);
          for(let i=0;i<6;i++) spawnTrail(s.tx + s.w*0.5 + rand(-20,20), s.ty + s.h*0.5 + rand(-20,20), s.color, rand(200,900));
        } else {
          // click (keyboard accessible too)
          card.animate([{ transform: card.style.transform + ' scale(1)' }, { transform: card.style.transform + ' scale(1.06)' }, { transform: card.style.transform + ' scale(1)' }], { duration: 300, easing: 'ease-out' });
        }
        window.removeEventListener('pointermove', onMove);
      }

      card.addEventListener('pointerdown', onDown);
      // keyboard: Enter or Space opens focus
      card.addEventListener('keydown', (ev) => {
        if(ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); focusCard(card); }
      });
      // prevent image dragging/select weirdness
      const img = card.querySelector('img');
      img.addEventListener('dragstart', e => e.preventDefault());
    }

    // focus card - accessible dialog
    function focusCard(card){
      const s = state.get(card);
      const img = card.querySelector('img');
      focusOverlay.innerHTML = '';
      const wrapper = document.createElement('div');
      wrapper.className = 'focus-card';
      wrapper.setAttribute('role','document');
      const clone = img.cloneNode(true);
      clone.alt = img.alt || 'Imagen ampliada';
      clone.loading = 'eager';
      wrapper.appendChild(clone);
      // close button
      const closeBtn = document.createElement('button');
      closeBtn.className = 'btn btn-dark tiny-btn';
      closeBtn.style.position = 'absolute';
      closeBtn.style.right = '18px';
      closeBtn.style.top = '18px';
      closeBtn.textContent = 'CERRAR';
      closeBtn.addEventListener('click', hideFocus);
      wrapper.appendChild(closeBtn);
      focusOverlay.appendChild(wrapper);
      focusOverlay.classList.add('show');
      focusOverlay.setAttribute('aria-hidden','false');
      // trap simple focus
      closeBtn.focus();
      function onKey(e){
        if(e.key === 'Escape') hideFocus();
      }
      document.addEventListener('keydown', onKey, { once: true });
      function hideFocus(){
        focusOverlay.classList.remove('show');
        focusOverlay.innerHTML = '';
        focusOverlay.setAttribute('aria-hidden','true');
      }
      // click outside closes
      focusOverlay.addEventListener('click', (ev) => {
        if(ev.target === focusOverlay) hideFocus();
      }, { once: true });
    }

    // shuffle positions and reorder DOM
    function shufflePositions(){
      cards.forEach(card => {
        const s = state.get(card);
        s.tx = rand(20, innerWidth - s.w - 20);
        s.ty = rand(20, innerHeight - s.h - 120);
        s.orbitRadius = rand(16,160);
        s.orbitSpeed = rand(0.0009,0.006) * (Math.random()>0.5?1:-1);
      });
      // shuffle DOM order for "chaos"
      const shuffled = [...cards].sort(()=>Math.random()-0.5);
      shuffled.forEach(c => gallery.appendChild(c));
    }

    // main animation tick
    function tick(now){
      const dt = Math.min(48, now - lastTime);
      lastTime = now;

      // draw background always
      drawBG();

      if(!motionPaused){
        // animate cards
        cards.forEach((card, idx) => {
          const s = state.get(card);
          // orbit movement if not being dragged
          if(!s.dragging){
            s.ang += s.orbitSpeed * dt;
            const ox = Math.cos(s.ang) * s.orbitRadius;
            const oy = Math.sin(s.ang) * (s.orbitRadius*0.6);
            const nx = Math.sin((now*0.0006) + idx) * 6;
            const ny = Math.cos((now*0.0008) + idx*1.3) * 6;
            s.x += (s.tx + ox + nx - s.x) * 0.075;
            s.y += (s.ty + oy + ny - s.y) * 0.075;
            s.rot += (Math.sin(now*0.001 + idx) * 0.03 - s.rot) * 0.06;
            applyTransform(card, Math.round(s.x), Math.round(s.y), s.rot);
          } else {
            // while dragging, move directly so it feels snappy
            s.x = s.tx;
            s.y = s.ty;
            applyTransform(card, Math.round(s.x), Math.round(s.y), s.rot);
          }

          // trails spawn chance (limited)
          if(Math.random() < 0.06) {
            spawnTrail(s.x + s.w*0.5 + rand(-8,8), s.y + s.h*0.5 + rand(-8,8), s.color, rand(200,700));
          }
        });

        drawTrails(dt);
        drawConnections(now);
      } else {
        // paused: draw lighter effects
        drawTrails(dt * 0.2);
        drawConnections(now);
      }

      rafId = requestAnimationFrame(tick);
    }

    // controls
    toggleMotionBtn.addEventListener('click', ()=>{
      motionPaused = !motionPaused;
      toggleMotionBtn.textContent = motionPaused ? 'REANUDAR' : 'PAUSAR';
      toggleMotionBtn.setAttribute('aria-pressed', motionPaused ? 'true' : 'false');
      modeBadge.style.opacity = motionPaused ? 0.5 : 1;
      if(!motionPaused){
        // nudges
        cards.forEach(c => {
          const s = state.get(c);
          s.tx = clamp(s.tx + rand(-60,60), 10, innerWidth - s.w - 10);
          s.ty = clamp(s.ty + rand(-60,60), 10, innerHeight - s.h - 120);
        });
      }
    });

    shuffleBtn.addEventListener('click', ()=>{
      shufflePositions();
      cards.forEach(c => {
        const s = state.get(c);
        for(let i=0;i<10;i++) spawnTrail(s.x + rand(-30,30) + s.w/2, s.y + rand(-30,30) + s.h/2, s.color, rand(200,900));
      });
    });

    // auto shuffle (stop when paused). Use timer but guard duplicates
    let autoShuffleTimer = setInterval(()=> {
      if(!motionPaused) shufflePositions();
    }, 7500);

    // init
    (function boot(){
      setCanvasSize(bgCanvas);
      setCanvasSize(trailsCanvas);
      setCanvasSize(connectCanvas);
      initBlobs();
      initCards();
      // initial shuffle for a bolder layout
      shufflePositions();
      lastTime = performance.now();
      rafId = requestAnimationFrame(tick);
    })();

    // cleanup on unload
    window.addEventListener('pagehide', ()=> {
      cancelAnimationFrame(rafId);
      clearInterval(autoShuffleTimer);
    });

    // accessibility: escape closes focus overlay
    window.addEventListener('keydown', (e) => {
      if(e.key === 'Escape'){
        focusOverlay.classList.remove('show');
        focusOverlay.innerHTML = '';
        focusOverlay.setAttribute('aria-hidden','true');
      }
    });

    /**********************
     * CONSEJOS DE RENDIMIENTO:
     * - Si en mÃ³viles va lento, reduce MAX_TRAILS o aumenta el umbral en spawnTrail.
     * - Puedes comentar los gradientes de fondo (.bg-glows) para bajar la carga.
     **********************/
  </script>
</body>
</html>
